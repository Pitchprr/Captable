import ExcelJS from 'exceljs';
import type { CapTable, WaterfallResult } from '../engine/types';

// Native save helper to avoid file-saver dependency issues
const saveAs = (blob: Blob, filename: string) => {
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.style.display = 'none'; // Ensure it's not visible
    document.body.appendChild(a);
    a.click();

    // Crucial: wait for browser to start download before revoking/removing
    setTimeout(() => {
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }, 200);
};

interface MnaExcelExportOptions {
    companyName: string;
    capTable: CapTable;
    waterfallResult?: WaterfallResult & { effectiveExitValuation?: number }; // Augmented type
    currency: 'EUR' | 'USD';
    includeFormulas: boolean;
    includeCoverPage: boolean;
}

const COLORS = {
    primary: '1F4788', // Dark Blue
    secondary: 'F2F2F2', // Light Gray
    border: 'D9D9D9', // Border Gray
    text: '000000',
    title: 'FFFFFF',
    danger: 'C00000', // Red for Confidential
    founder: 'D6E4F5', // Light Blue
    vc: 'E2EFD9', // Light Green
    angel: 'FCE4D6', // Light Orange
    options: 'FFF2CC', // Light Yellow
    highlight: 'FFF9E6', // Light Yellow for Inputs
};

export async function generateMAndAExcel(options: MnaExcelExportOptions) {
    const workbook = new ExcelJS.Workbook();

    // Metadata
    workbook.creator = 'Captable.inc';
    workbook.created = new Date();
    workbook.modified = new Date();

    // 1. Cover
    if (options.includeCoverPage) {
        createCoverSheet(workbook, options);
    }

    // 2. Summary
    createSummarySheet(workbook, options);

    // 3. Cap Table
    createCapTableSheet(workbook, options);

    // 4. Funding History
    createFundingHistorySheet(workbook, options);

    // 5. Waterfall
    if (options.waterfallResult) {
        createWaterfallSheet(workbook, options);
    }

    // 6. Parameters
    createParametersSheet(workbook, options);

    // Generate buffer
    const buffer = await workbook.xlsx.writeBuffer();

    // Trigger download
    const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
    const filename = `${options.companyName.replace(/[^a-z0-9]/gi, '_')}_Captable_Export_${new Date().toISOString().split('T')[0]}.xlsx`;
    saveAs(blob, filename);
}

// --- HELPER FUNCTIONS ---

function formatCurrency(currency: string): string {
    const symbol = currency === 'EUR' ? '€' : '$';
    return `"${symbol}" #,##0`;
}

function applyHeaderStyle(row: ExcelJS.Row) {
    row.eachCell((cell) => {
        cell.font = { bold: true };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: COLORS.secondary } };
        cell.border = {
            top: { style: 'thin', color: { argb: COLORS.border } },
            bottom: { style: 'thin', color: { argb: COLORS.border } },
            left: { style: 'thin', color: { argb: COLORS.border } },
            right: { style: 'thin', color: { argb: COLORS.border } }
        };
        cell.alignment = { vertical: 'middle', horizontal: 'center' };
    });
}

function createCoverSheet(workbook: ExcelJS.Workbook, options: MnaExcelExportOptions) {
    const sheet = workbook.addWorksheet('Cover', { views: [{ showGridLines: false }] });

    // Columns setup (approx width)
    sheet.columns = [
        { width: 18 }, { width: 18 }, { width: 18 }, { width: 18 }, { width: 18 }, { width: 18 } // A-F
    ];

    // Main Title
    sheet.mergeCells('A3:F3');
    const titleCell = sheet.getCell('A3');
    titleCell.value = "CAPITALIZATION TABLE & WATERFALL ANALYSIS";
    titleCell.alignment = { horizontal: 'center', vertical: 'middle' };
    titleCell.font = { name: 'Calibri', size: 16, bold: true, color: { argb: COLORS.primary } };

    // Company Name
    sheet.mergeCells('A5:F5');
    const companyCell = sheet.getCell('A5');
    companyCell.value = options.companyName || "My Company";
    companyCell.alignment = { horizontal: 'center', vertical: 'middle' };
    companyCell.font = { name: 'Calibri', size: 14, bold: true };

    // Date
    sheet.mergeCells('A7:F7');
    const dateCell = sheet.getCell('A7');
    dateCell.value = `As of ${new Date().toLocaleDateString()}`;
    dateCell.alignment = { horizontal: 'center', vertical: 'middle' };
    dateCell.font = { name: 'Calibri', size: 11, color: { argb: '5B6770' } };

    // Generated by
    sheet.mergeCells('A8:F8');
    const genCell = sheet.getCell('A8');
    genCell.value = "Generated by Captable.inc";
    genCell.alignment = { horizontal: 'center', vertical: 'middle' };
    genCell.font = { name: 'Calibri', size: 10, italic: true };

    // Separator
    sheet.mergeCells('A10:F10');
    const sepCell = sheet.getCell('A10');
    sepCell.value = "────────────────────────";
    sepCell.alignment = { horizontal: 'center', vertical: 'middle' };
    sepCell.font = { color: { argb: COLORS.border } };

    // Confidential
    sheet.mergeCells('A12:F12');
    const confCell = sheet.getCell('A12');
    confCell.value = "CONFIDENTIAL & PROPRIETARY";
    confCell.alignment = { horizontal: 'center', vertical: 'middle' };
    confCell.font = { name: 'Calibri', size: 11, bold: true, color: { argb: COLORS.danger } };

    sheet.mergeCells('A13:F13');
    const internalCell = sheet.getCell('A13');
    internalCell.value = "For internal use only";
    internalCell.alignment = { horizontal: 'center', vertical: 'middle' };
    internalCell.font = { name: 'Calibri', size: 10, color: { argb: '808080' } };
}

function createSummarySheet(workbook: ExcelJS.Workbook, options: MnaExcelExportOptions) {
    const sheet = workbook.addWorksheet('Summary', { views: [{ showGridLines: false }] });
    sheet.getColumn('A').width = 4;
    sheet.getColumn('B').width = 25;
    sheet.getColumn('C').width = 20;

    // Title
    sheet.mergeCells('A1:D1');
    const title = sheet.getCell('A1');
    title.value = "EXECUTIVE SUMMARY";
    title.font = { bold: true, size: 14 };

    // Helper for sections
    const addSection = (startRow: number, titleText: string, items: { label: string, formula?: string, value?: any, format?: string }[]) => {
        const header = sheet.getCell(`B${startRow}`);
        header.value = titleText;
        header.font = { bold: true, size: 12 };
        header.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: COLORS.secondary } };
        header.border = { top: { style: 'thin' }, bottom: { style: 'thin' }, left: { style: 'thin' }, right: { style: 'thin' } };
        sheet.mergeCells(`B${startRow}:C${startRow}`);

        items.forEach((item, idx) => {
            const r = startRow + 1 + idx;
            const labelCell = sheet.getCell(`B${r}`);
            labelCell.value = item.label;
            labelCell.font = { bold: true };
            labelCell.border = { left: { style: 'thin' } };

            const valCell = sheet.getCell(`C${r}`);
            if (item.formula && options.includeFormulas) {
                valCell.value = { formula: item.formula };
            } else {
                valCell.value = item.value ?? 0;
            }
            if (item.format) valCell.numFmt = item.format;
            valCell.border = { right: { style: 'thin' } };

            // Apply bottom border to last item
            if (idx === items.length - 1) {
                labelCell.border = { left: { style: 'thin' }, bottom: { style: 'thin' } };
                valCell.border = { right: { style: 'thin' }, bottom: { style: 'thin' } };
            }
        });
    };

    const currencyFmt = formatCurrency(options.currency);

    // Section 1: Company Info
    addSection(3, "Company Information", [
        { label: "Company Name:", value: options.companyName },
        { label: "Total Raised:", formula: "SUM('FundingHistory'!E:E)", format: currencyFmt },
        { label: "Current Valuation:", formula: "Parameters!B4", format: currencyFmt }, // Fixed Ref
        { label: "# Shareholders:", formula: "COUNTA('CapTable'!A:A)-4" }
    ]);

    // Section 2: Capitalization Overview
    addSection(9, "Capitalization Overview", [
        { label: "Fully Diluted Shares:", formula: "SUM('CapTable'!G:G)", format: '#,##0' },
        { label: "Common Shares:", formula: `SUMIF('CapTable'!B:B,"Founder",'CapTable'!G:G)+SUMIF('CapTable'!B:B,"Angel",'CapTable'!G:G)`, format: '#,##0' },
        { label: "Preferred Shares:", formula: `SUMIF('CapTable'!B:B,"VC",'CapTable'!G:G)`, format: '#,##0' },
        { label: "Options Outstanding:", formula: `SUMIF('CapTable'!B:B,"Options",'CapTable'!G:G)`, format: '#,##0' }
    ]);

    // Section 3: Ownership
    addSection(15, "Ownership Breakdown", [
        { label: "Founders:", formula: `SUMIF('CapTable'!B:B,"Founder",'CapTable'!H:H)`, format: '0.00%' },
        { label: "Investors:", formula: `SUMIF('CapTable'!B:B,"VC",'CapTable'!H:H)+SUMIF('CapTable'!B:B,"Angel",'CapTable'!H:H)`, format: '0.00%' },
        { label: "Employees:", formula: `SUMIF('CapTable'!B:B,"Options",'CapTable'!H:H)`, format: '0.00%' }
    ]);
}

function createCapTableSheet(workbook: ExcelJS.Workbook, options: MnaExcelExportOptions) {
    const sheet = workbook.addWorksheet('CapTable', {
        views: [{ state: 'frozen', xSplit: 2, ySplit: 4, showGridLines: false }]
    });

    // Determine Rounds for Columns C, D, E...
    const rounds = options.capTable.rounds;
    // We map rounds to columns.
    // A: Stakeholder, B: Type
    // C...: Rounds
    // Then after rounds: Total Shares, % FD, Invested, Current Value, Multiple

    const roundStartColIndex = 3; // C
    const roundCount = rounds.length;

    // Headers Row 4
    sheet.getRow(4).values = [
        'Stakeholder',
        'Type',
        ...rounds.map(r => r.name),
        'Total Shares',
        '% Fully Diluted',
        'Invested Amount',
        'Current Value',
        'Multiple'
    ];

    // Header Style
    const headerRow = sheet.getRow(4);
    applyHeaderStyle(headerRow);
    headerRow.height = 30;

    // Title
    sheet.mergeCells(1, 1, 1, 2 + roundCount + 5);
    const title = sheet.getCell('A1');
    title.value = "CAPITALIZATION TABLE";
    title.font = { bold: true, size: 14, color: { argb: 'FFFFFF' } };
    title.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: COLORS.primary } };
    title.alignment = { horizontal: 'center', vertical: 'middle' };

    sheet.mergeCells(2, 1, 2, 2 + roundCount + 5);
    const subtitle = sheet.getCell('A2');
    subtitle.value = `As of ${new Date().toLocaleDateString()}`;
    subtitle.font = { italic: true };
    subtitle.alignment = { horizontal: 'center', vertical: 'middle' };

    // Column Widths
    sheet.getColumn('A').width = 25; // Name
    sheet.getColumn('B').width = 15; // Type
    for (let i = 0; i < roundCount; i++) sheet.getColumn(roundStartColIndex + i).width = 15;
    sheet.getColumn(roundStartColIndex + roundCount).width = 15; // Total
    sheet.getColumn(roundStartColIndex + roundCount + 1).width = 15; // %
    sheet.getColumn(roundStartColIndex + roundCount + 2).width = 20; // Invested
    sheet.getColumn(roundStartColIndex + roundCount + 3).width = 20; // Value
    sheet.getColumn(roundStartColIndex + roundCount + 4).width = 10; // Multiple

    // Data Rows
    const shareholders = options.capTable.shareholders;
    const currencyFmt = formatCurrency(options.currency);

    let currentRow = 5;

    shareholders.forEach(sh => {
        const rowData: any[] = [];
        rowData[0] = sh.name;
        rowData[1] = sh.role; // Founder, VC, etc.

        let totalShares = 0;
        let totalInvested = 0;

        // Rounds Data
        rounds.forEach(r => {
            const inv = r.investments.find(i => i.shareholderId === sh.id);
            const shares = inv ? (inv.shares || inv.calculatedShares || 0) : 0;
            const invested = inv ? inv.amount : 0;
            rowData.push(shares);
            totalShares += shares;
            totalInvested += invested;
        });

        // Append calculated columns formulas
        const colTotalShares = getExcelAlpha(roundStartColIndex + roundCount); // G usually
        const colInvested = getExcelAlpha(roundStartColIndex + roundCount + 2); // I usually

        const startRoundCol = getExcelAlpha(3);
        const endRoundCol = getExcelAlpha(roundStartColIndex + roundCount - 1);
        const rowRef = currentRow;

        const totalSharesFormula = `SUM(${startRoundCol}${rowRef}:${endRoundCol}${rowRef})`;

        // Push Total Shares
        rowData.push(options.includeFormulas ? { formula: totalSharesFormula } : totalShares);

        // % FD (Col H)
        // We can't know the absolute Total row index yet easily without calculation. 
        // But we can name the Total Cell or use dynamic ref. 
        // Let's use a placeholder or just compute it after. 
        // Actually, easiest is `G${rowRef}/SUM($G$5:$G$${shareholders.length + 4})`
        const lastRowIndex = 4 + shareholders.length + 1; // +1 for total row
        const totalFDSumRef = `$${colTotalShares}$${lastRowIndex}`;
        const pctFormula = `${colTotalShares}${rowRef}/${totalFDSumRef}`;

        rowData.push(options.includeFormulas ? { formula: pctFormula } : 0); // Placeholder 0 if no formulas (value calc is complex here without engine run)

        // Invested
        rowData.push(totalInvested);

        // Current Value
        const ppsRef = "Parameters!$B$5";
        const valFormula = `${colTotalShares}${rowRef}*${ppsRef}`;
        rowData.push(options.includeFormulas ? { formula: valFormula } : 0);

        // Multiple
        const colCurrentVal = getExcelAlpha(roundStartColIndex + roundCount + 3);
        const multFormula = `IF(${colInvested}${rowRef}>0, ${colCurrentVal}${rowRef}/${colInvested}${rowRef}, "N/A")`;
        rowData.push(options.includeFormulas ? { formula: multFormula } : 0);

        // Add Row
        const r = sheet.addRow(rowData);

        // Formatting
        // Color based on Type
        let argb = 'FFFFFF';
        if (sh.role === 'Founder') argb = COLORS.founder;
        if (sh.role === 'VC') argb = COLORS.vc;
        if (sh.role === 'Angel') argb = COLORS.angel;
        if (sh.role === 'Other') argb = COLORS.options; // 'Options' usually mapped here if name matches

        r.getCell(2).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb } };

        // Number formats
        r.getCell(roundStartColIndex + roundCount).numFmt = '#,##0'; // Total Shares
        r.getCell(roundStartColIndex + roundCount + 1).numFmt = '0.00%'; // %
        r.getCell(roundStartColIndex + roundCount + 2).numFmt = currencyFmt; // Invested
        r.getCell(roundStartColIndex + roundCount + 3).numFmt = currencyFmt; // Value
        r.getCell(roundStartColIndex + roundCount + 4).numFmt = '0.0x'; // Multiple

        currentRow++;
    });

    // Total Row
    const totalRow = sheet.addRow([]);
    totalRow.getCell(1).value = "TOTAL FULLY DILUTED";
    totalRow.font = { bold: true };
    totalRow.getCell(roundStartColIndex + roundCount).value = { formula: `SUM(${getExcelAlpha(roundStartColIndex + roundCount)}5:${getExcelAlpha(roundStartColIndex + roundCount)}${currentRow - 1})` };
    totalRow.getCell(roundStartColIndex + roundCount).numFmt = '#,##0';

    // Total Invested
    totalRow.getCell(roundStartColIndex + roundCount + 2).value = { formula: `SUM(${getExcelAlpha(roundStartColIndex + roundCount + 2)}5:${getExcelAlpha(roundStartColIndex + roundCount + 2)}${currentRow - 1})` };
    totalRow.getCell(roundStartColIndex + roundCount + 2).numFmt = currencyFmt;

    // Total Value
    totalRow.getCell(roundStartColIndex + roundCount + 3).value = { formula: `SUM(${getExcelAlpha(roundStartColIndex + roundCount + 3)}5:${getExcelAlpha(roundStartColIndex + roundCount + 3)}${currentRow - 1})` };
    totalRow.getCell(roundStartColIndex + roundCount + 3).numFmt = currencyFmt;
}

function createFundingHistorySheet(workbook: ExcelJS.Workbook, options: MnaExcelExportOptions) {
    const sheet = workbook.addWorksheet('FundingHistory', { views: [{ showGridLines: false }] });
    // Headers setup...
    sheet.columns = [
        { width: 20 }, { width: 15 }, { width: 15 }, { width: 18 }, { width: 18 }, { width: 18 }, { width: 18 }, { width: 15 }, { width: 20 }, { width: 20 }
    ];

    // Title
    sheet.mergeCells('A1:J1');
    const title = sheet.getCell('A1');
    title.value = "FUNDING ROUNDS HISTORY";
    title.font = { bold: true, size: 14, color: { argb: 'FFFFFF' } };
    title.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: COLORS.primary } };
    title.alignment = { horizontal: 'center', vertical: 'middle' };

    // Headers
    const headers = ['Round Name', 'Date', 'Type', 'Pre-Money Val.', 'Amount Raised', 'Post-Money Val.', 'New Shares', 'Price / Share', 'Lead Investor', 'Liq. Pref.'];
    const headerRow = sheet.getRow(3);
    headerRow.values = headers;
    applyHeaderStyle(headerRow);

    const currencyFmt = formatCurrency(options.currency);
    const rounds = options.capTable.rounds;
    let currentRow = 4;

    rounds.forEach(r => {
        // Calculate Post-Money = Pre + Raised. If Pre is undef, assume 0 for calc (not ideal but avoids crash)
        const rRaised = r.investments.reduce((acc, inv) => acc + inv.amount, 0);

        const row = sheet.addRow([
            r.name,
            r.date,
            r.investmentType || 'Equity',
            r.preMoneyValuation || 0,
            rRaised,
            // Formula for Post Money = Pre + Raised
            { formula: `D${currentRow}+E${currentRow}` },
            r.newSharesIssued || r.calculatedNewSharesIssued || 0,
            { formula: `E${currentRow}/G${currentRow}` }, // PPS
            'TBD', // Lead investor not in model currently
            r.liquidationPreferenceMultiple ? `${r.liquidationPreferenceMultiple}x ${r.isParticipating ? 'Part' : 'Non-Part'}` : '-'
        ]);

        row.getCell(4).numFmt = currencyFmt;
        row.getCell(5).numFmt = currencyFmt;
        row.getCell(6).numFmt = currencyFmt;
        row.getCell(7).numFmt = '#,##0';
        row.getCell(8).numFmt = currencyFmt;

        currentRow++;
    });

    // Total Row
    const totalRow = sheet.addRow([]);
    totalRow.getCell(1).value = "TOTAL";
    totalRow.font = { bold: true };
    totalRow.getCell(5).value = { formula: `SUM(E4:E${currentRow - 1})` };
    totalRow.getCell(5).numFmt = currencyFmt;
}

function createWaterfallSheet(workbook: ExcelJS.Workbook, options: MnaExcelExportOptions) {
    if (!options.waterfallResult) return;
    const sheet = workbook.addWorksheet('Waterfall', { views: [{ showGridLines: false }] });

    // Headers
    sheet.columns = [
        { width: 25 }, { width: 15 }, { width: 15 }, { width: 15 },
        { width: 18 }, { width: 18 }, { width: 18 }, { width: 18 },
        { width: 20 }, { width: 12 }, { width: 10 }
    ];

    // Title
    sheet.mergeCells('A1:K1');
    const title = sheet.getCell('A1');
    title.value = "WATERFALL DISTRIBUTION ANALYSIS";
    title.font = { bold: true, size: 14 };

    // Exit Valuation
    sheet.mergeCells('A2:C2');
    sheet.getCell('A2').value = "Exit Valuation Scenario:";
    sheet.getCell('D2').value = { formula: "Parameters!B6" };
    sheet.getCell('D2').numFmt = formatCurrency(options.currency);
    sheet.getCell('D2').font = { bold: true };

    // Table Headers
    const headers = [
        'Stakeholder', 'Type', 'Total Shares', '% Fully Diluted',
        'Liq. Pref.', 'Participation', 'Carve-Out', 'Catch-Up',
        'TOTAL Proceeds', '% of Exit', 'Multiple'
    ];

    const headerRow = sheet.getRow(4);
    headerRow.values = headers;
    applyHeaderStyle(headerRow);

    const payouts = options.waterfallResult.payouts;
    const currencyFmt = formatCurrency(options.currency);
    let currentRow = 5;

    payouts.forEach(p => {
        // Need to find Total Shares for this stakeholder from CapTable to be accurate?
        // Or assume it's passed. `p.totalInvested` is there.
        // We can link to Cap Table or use static values.
        // For simplicity, we use values from the result object.

        const rowData = [
            p.shareholderName,
            'TBD', // Type
            0, // Shares (need lookup)
            0, // % FD
            p.preferencePayout,
            p.participationPayout,
            p.carveOutPayout,
            0, // Catchup
            p.totalPayout, // TOTAL
            { formula: `I${currentRow}/$D$2` }, // % of Exit
            p.multiple
        ];

        const row = sheet.addRow(rowData);
        row.getCell(5).numFmt = currencyFmt;
        row.getCell(6).numFmt = currencyFmt;
        row.getCell(7).numFmt = currencyFmt;
        row.getCell(8).numFmt = currencyFmt;
        row.getCell(9).numFmt = currencyFmt;
        row.getCell(10).numFmt = '0.00%';
        row.getCell(11).numFmt = '0.00x';

        currentRow++;
    });

    // Footer total
    const totalRow = sheet.addRow([]);
    totalRow.getCell(1).value = "TOTAL DISTRIBUTED";
    totalRow.font = { bold: true };
    totalRow.getCell(9).value = { formula: `SUM(I5:I${currentRow - 1})` };
    totalRow.getCell(9).numFmt = currencyFmt;
}

function createParametersSheet(workbook: ExcelJS.Workbook, options: MnaExcelExportOptions) {
    const sheet = workbook.addWorksheet('Parameters', { views: [{ showGridLines: false }] });
    sheet.getColumn('A').width = 30;
    sheet.getColumn('B').width = 20;

    sheet.mergeCells('A1:D1');
    const title = sheet.getCell('A1');
    title.value = "PARAMETERS & ASSUMPTIONS";
    title.font = { bold: true, size: 14 };

    const currencyFmt = formatCurrency(options.currency);
    const lastRound = options.capTable.rounds[options.capTable.rounds.length - 1];
    // Calculate post money safely
    const rPre = lastRound ? (lastRound.preMoneyValuation || 0) : 0;
    const rRaised = lastRound ? lastRound.investments.reduce((s, i) => s + i.amount, 0) : 0;
    const currentValu = rPre + rRaised;

    // Helper
    const addParam = (row: number, label: string, value: any, format?: string, isInput = false) => {
        sheet.getCell(`A${row}`).value = label;
        const c = sheet.getCell(`B${row}`);
        c.value = value;
        if (format) c.numFmt = format;
        if (isInput) c.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: COLORS.highlight } };
        else c.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: COLORS.secondary } };

        sheet.getCell(`A${row}`).border = { bottom: { style: 'thin', color: { argb: COLORS.border } } };
        c.border = { bottom: { style: 'thin', color: { argb: COLORS.border } } };
    };

    sheet.getCell('A3').value = "Valuation Parameters";
    sheet.getCell('A3').font = { bold: true };

    addParam(4, "Current Valuation (€):", currentValu, currencyFmt, true);
    addParam(5, "Price per Share (€):", { formula: "B4/'Summary'!C10" }, currencyFmt); // Linking to Summary FD shares

    // Exit Val
    const exitVal = options.waterfallResult?.effectiveExitValuation || 0;
    addParam(6, "Exit Valuation (€):", exitVal, currencyFmt, true);

    sheet.getCell('A8').value = "Funding Overview";
    sheet.getCell('A8').font = { bold: true };
    addParam(9, "Total Raised (€):", { formula: "SUM('FundingHistory'!E:E)" }, currencyFmt);
    addParam(10, "Number of Rounds:", { formula: "COUNTA('FundingHistory'!A:A)-1" });
}

// Utils
function getExcelAlpha(colIndex: number): string {
    // 1 -> A, 2 -> B... 27 -> AA
    let label = '';
    while (colIndex > 0) {
        let remainder = (colIndex - 1) % 26;
        label = String.fromCharCode(65 + remainder) + label;
        colIndex = Math.floor((colIndex - 1) / 26);
    }
    return label;
}
